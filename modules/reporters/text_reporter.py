#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Text Reporter
Generates plain text format reports for QC results
"""

import logging
from typing import Dict, Any
from .base_reporter import BaseReporter

logger = logging.getLogger(__name__)


class TextReporter(BaseReporter):
    """
    Text report generator for quality control results.
    """
    
    def __init__(self):
        """Initialize text reporter."""
        super().__init__()
        self.report_format = "text"
    
    def generate_report(self, results: Dict[str, Any], output_path: str) -> bool:
        """
        Generate text report from QC results.
        
        Args:
            results: QC results dictionary
            output_path: Path to save text report
            
        Returns:
            True if successful, False otherwise
        """
        try:
            filename = results.get('filename', 'Unknown File')
            
            # Generate text content
            text_content = [
                "=" * 60,
                "QUALITY CONTROL REPORT",
                "=" * 60,
                f"File: {filename}",
                f"Generated: {self._get_current_date()}",
                "=" * 60,
                ""
            ]
            
            # Add quality status
            quality_status = results.get('quality_status', 'UNKNOWN')
            text_content.extend([
                "QUALITY STATUS",
                "-" * 20,
                f"Status: {quality_status}",
                ""
            ])
            
            # Add validation results
            if 'validation' in results:
                validation = results['validation']
                text_content.extend([
                    "VALIDATION RESULTS",
                    "-" * 20,
                    f"Valid: {'Yes' if validation.get('valid', False) else 'No'}"
                ])
                
                if 'format' in validation:
                    text_content.append(f"Format: {validation['format']}")
                
                if 'errors' in validation and validation['errors']:
                    text_content.append("")
                    text_content.append("Errors:")
                    for error in validation['errors']:
                        text_content.append(f"  - {error}")
                
                if 'warnings' in validation and validation['warnings']:
                    text_content.append("")
                    text_content.append("Warnings:")
                    for warning in validation['warnings']:
                        text_content.append(f"  - {warning}")
                
                text_content.append("")
            
            # Add QC metrics
            if 'metrics' in results and results['metrics']:
                text_content.extend([
                    "QC METRICS",
                    "-" * 20
                ])
                
                for key, value in results['metrics'].items():
                    formatted_name = self._format_metric_name(key)
                    formatted_value = self._format_metric_value(value)
                    text_content.append(f"{formatted_name}: {formatted_value}")
                
                text_content.append("")
            
            # Add footer
            text_content.extend([
                "=" * 60,
                "Report generated by QualityControlSuite v1.0.0",
                "=" * 60
            ])
            
            # Write text report
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write('\n'.join(text_content))
            
            logger.info(f"Text report generated: {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"Error generating text report: {str(e)}")
            return False
    
    def _format_metric_value(self, value) -> str:
        """Format metric value for display."""
        if isinstance(value, float):
            return f"{value:.2f}"
        elif isinstance(value, int):
            return f"{value:,}"
        else:
            return str(value)
    
    def _get_current_date(self) -> str:
        """Get current date as string."""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")